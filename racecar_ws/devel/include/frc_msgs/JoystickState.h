// Generated by gencpp from file frc_msgs/JoystickState.msg
// DO NOT EDIT!


#ifndef FRC_MSGS_MESSAGE_JOYSTICKSTATE_H
#define FRC_MSGS_MESSAGE_JOYSTICKSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace frc_msgs
{
template <class ContainerAllocator>
struct JoystickState_
{
  typedef JoystickState_<ContainerAllocator> Type;

  JoystickState_()
    : header()
    , leftStickX(0.0)
    , leftStickY(0.0)
    , rightStickX(0.0)
    , rightStickY(0.0)
    , leftTrigger(0.0)
    , rightTrigger(0.0)
    , buttonAButton(false)
    , buttonAPress(false)
    , buttonARelease(false)
    , buttonBButton(false)
    , buttonBPress(false)
    , buttonBRelease(false)
    , buttonXButton(false)
    , buttonXPress(false)
    , buttonXRelease(false)
    , buttonYButton(false)
    , buttonYPress(false)
    , buttonYRelease(false)
    , bumperLeftButton(false)
    , bumperLeftPress(false)
    , bumperLeftRelease(false)
    , bumperRightButton(false)
    , bumperRightPress(false)
    , bumperRightRelease(false)
    , buttonBackButton(false)
    , buttonBackPress(false)
    , buttonBackRelease(false)
    , buttonStartButton(false)
    , buttonStartPress(false)
    , buttonStartRelease(false)
    , stickLeftButton(false)
    , stickLeftPress(false)
    , stickLeftRelease(false)
    , stickRightButton(false)
    , stickRightPress(false)
    , stickRightRelease(false)
    , directionUpButton(false)
    , directionUpPress(false)
    , directionUpRelease(false)
    , directionDownButton(false)
    , directionDownPress(false)
    , directionDownRelease(false)
    , directionLeftButton(false)
    , directionLeftPress(false)
    , directionLeftRelease(false)
    , directionRightButton(false)
    , directionRightPress(false)
    , directionRightRelease(false)  {
    }
  JoystickState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , leftStickX(0.0)
    , leftStickY(0.0)
    , rightStickX(0.0)
    , rightStickY(0.0)
    , leftTrigger(0.0)
    , rightTrigger(0.0)
    , buttonAButton(false)
    , buttonAPress(false)
    , buttonARelease(false)
    , buttonBButton(false)
    , buttonBPress(false)
    , buttonBRelease(false)
    , buttonXButton(false)
    , buttonXPress(false)
    , buttonXRelease(false)
    , buttonYButton(false)
    , buttonYPress(false)
    , buttonYRelease(false)
    , bumperLeftButton(false)
    , bumperLeftPress(false)
    , bumperLeftRelease(false)
    , bumperRightButton(false)
    , bumperRightPress(false)
    , bumperRightRelease(false)
    , buttonBackButton(false)
    , buttonBackPress(false)
    , buttonBackRelease(false)
    , buttonStartButton(false)
    , buttonStartPress(false)
    , buttonStartRelease(false)
    , stickLeftButton(false)
    , stickLeftPress(false)
    , stickLeftRelease(false)
    , stickRightButton(false)
    , stickRightPress(false)
    , stickRightRelease(false)
    , directionUpButton(false)
    , directionUpPress(false)
    , directionUpRelease(false)
    , directionDownButton(false)
    , directionDownPress(false)
    , directionDownRelease(false)
    , directionLeftButton(false)
    , directionLeftPress(false)
    , directionLeftRelease(false)
    , directionRightButton(false)
    , directionRightPress(false)
    , directionRightRelease(false)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _leftStickX_type;
  _leftStickX_type leftStickX;

   typedef double _leftStickY_type;
  _leftStickY_type leftStickY;

   typedef double _rightStickX_type;
  _rightStickX_type rightStickX;

   typedef double _rightStickY_type;
  _rightStickY_type rightStickY;

   typedef double _leftTrigger_type;
  _leftTrigger_type leftTrigger;

   typedef double _rightTrigger_type;
  _rightTrigger_type rightTrigger;

   typedef uint8_t _buttonAButton_type;
  _buttonAButton_type buttonAButton;

   typedef uint8_t _buttonAPress_type;
  _buttonAPress_type buttonAPress;

   typedef uint8_t _buttonARelease_type;
  _buttonARelease_type buttonARelease;

   typedef uint8_t _buttonBButton_type;
  _buttonBButton_type buttonBButton;

   typedef uint8_t _buttonBPress_type;
  _buttonBPress_type buttonBPress;

   typedef uint8_t _buttonBRelease_type;
  _buttonBRelease_type buttonBRelease;

   typedef uint8_t _buttonXButton_type;
  _buttonXButton_type buttonXButton;

   typedef uint8_t _buttonXPress_type;
  _buttonXPress_type buttonXPress;

   typedef uint8_t _buttonXRelease_type;
  _buttonXRelease_type buttonXRelease;

   typedef uint8_t _buttonYButton_type;
  _buttonYButton_type buttonYButton;

   typedef uint8_t _buttonYPress_type;
  _buttonYPress_type buttonYPress;

   typedef uint8_t _buttonYRelease_type;
  _buttonYRelease_type buttonYRelease;

   typedef uint8_t _bumperLeftButton_type;
  _bumperLeftButton_type bumperLeftButton;

   typedef uint8_t _bumperLeftPress_type;
  _bumperLeftPress_type bumperLeftPress;

   typedef uint8_t _bumperLeftRelease_type;
  _bumperLeftRelease_type bumperLeftRelease;

   typedef uint8_t _bumperRightButton_type;
  _bumperRightButton_type bumperRightButton;

   typedef uint8_t _bumperRightPress_type;
  _bumperRightPress_type bumperRightPress;

   typedef uint8_t _bumperRightRelease_type;
  _bumperRightRelease_type bumperRightRelease;

   typedef uint8_t _buttonBackButton_type;
  _buttonBackButton_type buttonBackButton;

   typedef uint8_t _buttonBackPress_type;
  _buttonBackPress_type buttonBackPress;

   typedef uint8_t _buttonBackRelease_type;
  _buttonBackRelease_type buttonBackRelease;

   typedef uint8_t _buttonStartButton_type;
  _buttonStartButton_type buttonStartButton;

   typedef uint8_t _buttonStartPress_type;
  _buttonStartPress_type buttonStartPress;

   typedef uint8_t _buttonStartRelease_type;
  _buttonStartRelease_type buttonStartRelease;

   typedef uint8_t _stickLeftButton_type;
  _stickLeftButton_type stickLeftButton;

   typedef uint8_t _stickLeftPress_type;
  _stickLeftPress_type stickLeftPress;

   typedef uint8_t _stickLeftRelease_type;
  _stickLeftRelease_type stickLeftRelease;

   typedef uint8_t _stickRightButton_type;
  _stickRightButton_type stickRightButton;

   typedef uint8_t _stickRightPress_type;
  _stickRightPress_type stickRightPress;

   typedef uint8_t _stickRightRelease_type;
  _stickRightRelease_type stickRightRelease;

   typedef uint8_t _directionUpButton_type;
  _directionUpButton_type directionUpButton;

   typedef uint8_t _directionUpPress_type;
  _directionUpPress_type directionUpPress;

   typedef uint8_t _directionUpRelease_type;
  _directionUpRelease_type directionUpRelease;

   typedef uint8_t _directionDownButton_type;
  _directionDownButton_type directionDownButton;

   typedef uint8_t _directionDownPress_type;
  _directionDownPress_type directionDownPress;

   typedef uint8_t _directionDownRelease_type;
  _directionDownRelease_type directionDownRelease;

   typedef uint8_t _directionLeftButton_type;
  _directionLeftButton_type directionLeftButton;

   typedef uint8_t _directionLeftPress_type;
  _directionLeftPress_type directionLeftPress;

   typedef uint8_t _directionLeftRelease_type;
  _directionLeftRelease_type directionLeftRelease;

   typedef uint8_t _directionRightButton_type;
  _directionRightButton_type directionRightButton;

   typedef uint8_t _directionRightPress_type;
  _directionRightPress_type directionRightPress;

   typedef uint8_t _directionRightRelease_type;
  _directionRightRelease_type directionRightRelease;





  typedef boost::shared_ptr< ::frc_msgs::JoystickState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::frc_msgs::JoystickState_<ContainerAllocator> const> ConstPtr;

}; // struct JoystickState_

typedef ::frc_msgs::JoystickState_<std::allocator<void> > JoystickState;

typedef boost::shared_ptr< ::frc_msgs::JoystickState > JoystickStatePtr;
typedef boost::shared_ptr< ::frc_msgs::JoystickState const> JoystickStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::frc_msgs::JoystickState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::frc_msgs::JoystickState_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace frc_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'frc_msgs': ['/home/niallmullane/racecar_ws/racecar_ws/src/frc_msgs/msg', '/home/niallmullane/racecar_ws/racecar_ws/src/frc_msgs/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::frc_msgs::JoystickState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::frc_msgs::JoystickState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::frc_msgs::JoystickState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::frc_msgs::JoystickState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::frc_msgs::JoystickState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::frc_msgs::JoystickState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::frc_msgs::JoystickState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "94b495e8f7801eaec0cdd481668e94e0";
  }

  static const char* value(const ::frc_msgs::JoystickState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x94b495e8f7801eaeULL;
  static const uint64_t static_value2 = 0xc0cdd481668e94e0ULL;
};

template<class ContainerAllocator>
struct DataType< ::frc_msgs::JoystickState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "frc_msgs/JoystickState";
  }

  static const char* value(const ::frc_msgs::JoystickState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::frc_msgs::JoystickState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
\n\
float64  leftStickX\n\
float64  leftStickY\n\
\n\
float64  rightStickX\n\
float64  rightStickY\n\
\n\
float64  leftTrigger\n\
float64  rightTrigger\n\
\n\
bool buttonAButton\n\
bool buttonAPress\n\
bool buttonARelease\n\
\n\
bool buttonBButton\n\
bool buttonBPress\n\
bool buttonBRelease\n\
\n\
bool buttonXButton\n\
bool buttonXPress\n\
bool buttonXRelease\n\
\n\
bool buttonYButton\n\
bool buttonYPress\n\
bool buttonYRelease\n\
\n\
bool bumperLeftButton\n\
bool bumperLeftPress\n\
bool bumperLeftRelease\n\
\n\
bool bumperRightButton\n\
bool bumperRightPress\n\
bool bumperRightRelease\n\
\n\
bool buttonBackButton\n\
bool buttonBackPress\n\
bool buttonBackRelease\n\
\n\
bool buttonStartButton\n\
bool buttonStartPress\n\
bool buttonStartRelease\n\
\n\
bool stickLeftButton\n\
bool stickLeftPress\n\
bool stickLeftRelease\n\
\n\
bool stickRightButton\n\
bool stickRightPress\n\
bool stickRightRelease\n\
\n\
bool directionUpButton\n\
bool directionUpPress\n\
bool directionUpRelease\n\
\n\
bool directionDownButton\n\
bool directionDownPress\n\
bool directionDownRelease\n\
\n\
bool directionLeftButton\n\
bool directionLeftPress\n\
bool directionLeftRelease\n\
\n\
bool directionRightButton\n\
bool directionRightPress\n\
bool directionRightRelease\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::frc_msgs::JoystickState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::frc_msgs::JoystickState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.leftStickX);
      stream.next(m.leftStickY);
      stream.next(m.rightStickX);
      stream.next(m.rightStickY);
      stream.next(m.leftTrigger);
      stream.next(m.rightTrigger);
      stream.next(m.buttonAButton);
      stream.next(m.buttonAPress);
      stream.next(m.buttonARelease);
      stream.next(m.buttonBButton);
      stream.next(m.buttonBPress);
      stream.next(m.buttonBRelease);
      stream.next(m.buttonXButton);
      stream.next(m.buttonXPress);
      stream.next(m.buttonXRelease);
      stream.next(m.buttonYButton);
      stream.next(m.buttonYPress);
      stream.next(m.buttonYRelease);
      stream.next(m.bumperLeftButton);
      stream.next(m.bumperLeftPress);
      stream.next(m.bumperLeftRelease);
      stream.next(m.bumperRightButton);
      stream.next(m.bumperRightPress);
      stream.next(m.bumperRightRelease);
      stream.next(m.buttonBackButton);
      stream.next(m.buttonBackPress);
      stream.next(m.buttonBackRelease);
      stream.next(m.buttonStartButton);
      stream.next(m.buttonStartPress);
      stream.next(m.buttonStartRelease);
      stream.next(m.stickLeftButton);
      stream.next(m.stickLeftPress);
      stream.next(m.stickLeftRelease);
      stream.next(m.stickRightButton);
      stream.next(m.stickRightPress);
      stream.next(m.stickRightRelease);
      stream.next(m.directionUpButton);
      stream.next(m.directionUpPress);
      stream.next(m.directionUpRelease);
      stream.next(m.directionDownButton);
      stream.next(m.directionDownPress);
      stream.next(m.directionDownRelease);
      stream.next(m.directionLeftButton);
      stream.next(m.directionLeftPress);
      stream.next(m.directionLeftRelease);
      stream.next(m.directionRightButton);
      stream.next(m.directionRightPress);
      stream.next(m.directionRightRelease);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct JoystickState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::frc_msgs::JoystickState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::frc_msgs::JoystickState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "leftStickX: ";
    Printer<double>::stream(s, indent + "  ", v.leftStickX);
    s << indent << "leftStickY: ";
    Printer<double>::stream(s, indent + "  ", v.leftStickY);
    s << indent << "rightStickX: ";
    Printer<double>::stream(s, indent + "  ", v.rightStickX);
    s << indent << "rightStickY: ";
    Printer<double>::stream(s, indent + "  ", v.rightStickY);
    s << indent << "leftTrigger: ";
    Printer<double>::stream(s, indent + "  ", v.leftTrigger);
    s << indent << "rightTrigger: ";
    Printer<double>::stream(s, indent + "  ", v.rightTrigger);
    s << indent << "buttonAButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonAButton);
    s << indent << "buttonAPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonAPress);
    s << indent << "buttonARelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonARelease);
    s << indent << "buttonBButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonBButton);
    s << indent << "buttonBPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonBPress);
    s << indent << "buttonBRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonBRelease);
    s << indent << "buttonXButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonXButton);
    s << indent << "buttonXPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonXPress);
    s << indent << "buttonXRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonXRelease);
    s << indent << "buttonYButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonYButton);
    s << indent << "buttonYPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonYPress);
    s << indent << "buttonYRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonYRelease);
    s << indent << "bumperLeftButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumperLeftButton);
    s << indent << "bumperLeftPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumperLeftPress);
    s << indent << "bumperLeftRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumperLeftRelease);
    s << indent << "bumperRightButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumperRightButton);
    s << indent << "bumperRightPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumperRightPress);
    s << indent << "bumperRightRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bumperRightRelease);
    s << indent << "buttonBackButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonBackButton);
    s << indent << "buttonBackPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonBackPress);
    s << indent << "buttonBackRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonBackRelease);
    s << indent << "buttonStartButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonStartButton);
    s << indent << "buttonStartPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonStartPress);
    s << indent << "buttonStartRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.buttonStartRelease);
    s << indent << "stickLeftButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stickLeftButton);
    s << indent << "stickLeftPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stickLeftPress);
    s << indent << "stickLeftRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stickLeftRelease);
    s << indent << "stickRightButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stickRightButton);
    s << indent << "stickRightPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stickRightPress);
    s << indent << "stickRightRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stickRightRelease);
    s << indent << "directionUpButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionUpButton);
    s << indent << "directionUpPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionUpPress);
    s << indent << "directionUpRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionUpRelease);
    s << indent << "directionDownButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionDownButton);
    s << indent << "directionDownPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionDownPress);
    s << indent << "directionDownRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionDownRelease);
    s << indent << "directionLeftButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionLeftButton);
    s << indent << "directionLeftPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionLeftPress);
    s << indent << "directionLeftRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionLeftRelease);
    s << indent << "directionRightButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionRightButton);
    s << indent << "directionRightPress: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionRightPress);
    s << indent << "directionRightRelease: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.directionRightRelease);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FRC_MSGS_MESSAGE_JOYSTICKSTATE_H
