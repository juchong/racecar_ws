// Generated by gencpp from file frc_msgs/RobotControllerData.msg
// DO NOT EDIT!


#ifndef FRC_MSGS_MESSAGE_ROBOTCONTROLLERDATA_H
#define FRC_MSGS_MESSAGE_ROBOTCONTROLLERDATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <frc_msgs/RobotControllerCANData.h>

namespace frc_msgs
{
template <class ContainerAllocator>
struct RobotControllerData_
{
  typedef RobotControllerData_<ContainerAllocator> Type;

  RobotControllerData_()
    : header()
    , fpgaVersion(0)
    , fpgaRevision(0)
    , fpgaTime(0)
    , userButton(false)
    , isSysActive(false)
    , isBrownedOut(false)
    , inputVoltage(0.0)
    , inputCurrent(0.0)
    , voltage3V3(0.0)
    , current3V3(0.0)
    , enabled3V3(false)
    , faultCount3V3(0)
    , voltage5V(0.0)
    , current5V(0.0)
    , enabled5V(false)
    , faultCount5V(0)
    , voltage6V(0.0)
    , current6V(0.0)
    , enabled6V(false)
    , faultCount6V(0)
    , canData()  {
    }
  RobotControllerData_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , fpgaVersion(0)
    , fpgaRevision(0)
    , fpgaTime(0)
    , userButton(false)
    , isSysActive(false)
    , isBrownedOut(false)
    , inputVoltage(0.0)
    , inputCurrent(0.0)
    , voltage3V3(0.0)
    , current3V3(0.0)
    , enabled3V3(false)
    , faultCount3V3(0)
    , voltage5V(0.0)
    , current5V(0.0)
    , enabled5V(false)
    , faultCount5V(0)
    , voltage6V(0.0)
    , current6V(0.0)
    , enabled6V(false)
    , faultCount6V(0)
    , canData(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int32_t _fpgaVersion_type;
  _fpgaVersion_type fpgaVersion;

   typedef int64_t _fpgaRevision_type;
  _fpgaRevision_type fpgaRevision;

   typedef uint64_t _fpgaTime_type;
  _fpgaTime_type fpgaTime;

   typedef uint8_t _userButton_type;
  _userButton_type userButton;

   typedef uint8_t _isSysActive_type;
  _isSysActive_type isSysActive;

   typedef uint8_t _isBrownedOut_type;
  _isBrownedOut_type isBrownedOut;

   typedef double _inputVoltage_type;
  _inputVoltage_type inputVoltage;

   typedef double _inputCurrent_type;
  _inputCurrent_type inputCurrent;

   typedef double _voltage3V3_type;
  _voltage3V3_type voltage3V3;

   typedef double _current3V3_type;
  _current3V3_type current3V3;

   typedef uint8_t _enabled3V3_type;
  _enabled3V3_type enabled3V3;

   typedef int32_t _faultCount3V3_type;
  _faultCount3V3_type faultCount3V3;

   typedef double _voltage5V_type;
  _voltage5V_type voltage5V;

   typedef double _current5V_type;
  _current5V_type current5V;

   typedef uint8_t _enabled5V_type;
  _enabled5V_type enabled5V;

   typedef int32_t _faultCount5V_type;
  _faultCount5V_type faultCount5V;

   typedef double _voltage6V_type;
  _voltage6V_type voltage6V;

   typedef double _current6V_type;
  _current6V_type current6V;

   typedef uint8_t _enabled6V_type;
  _enabled6V_type enabled6V;

   typedef int32_t _faultCount6V_type;
  _faultCount6V_type faultCount6V;

   typedef  ::frc_msgs::RobotControllerCANData_<ContainerAllocator>  _canData_type;
  _canData_type canData;





  typedef boost::shared_ptr< ::frc_msgs::RobotControllerData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::frc_msgs::RobotControllerData_<ContainerAllocator> const> ConstPtr;

}; // struct RobotControllerData_

typedef ::frc_msgs::RobotControllerData_<std::allocator<void> > RobotControllerData;

typedef boost::shared_ptr< ::frc_msgs::RobotControllerData > RobotControllerDataPtr;
typedef boost::shared_ptr< ::frc_msgs::RobotControllerData const> RobotControllerDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::frc_msgs::RobotControllerData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::frc_msgs::RobotControllerData_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace frc_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'frc_msgs': ['/home/niallmullane/racecar_ws/racecar_ws/src/frc_msgs/msg', '/home/niallmullane/racecar_ws/racecar_ws/src/frc_msgs/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::frc_msgs::RobotControllerData_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::frc_msgs::RobotControllerData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::frc_msgs::RobotControllerData_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bd038fd2805831a80b16311cd50a4a1d";
  }

  static const char* value(const ::frc_msgs::RobotControllerData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xbd038fd2805831a8ULL;
  static const uint64_t static_value2 = 0x0b16311cd50a4a1dULL;
};

template<class ContainerAllocator>
struct DataType< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "frc_msgs/RobotControllerData";
  }

  static const char* value(const ::frc_msgs::RobotControllerData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
\n\
int32 fpgaVersion\n\
int64 fpgaRevision\n\
uint64 fpgaTime\n\
bool userButton\n\
bool isSysActive\n\
bool isBrownedOut\n\
float64 inputVoltage\n\
float64 inputCurrent\n\
float64 voltage3V3\n\
float64 current3V3\n\
bool enabled3V3\n\
int32 faultCount3V3\n\
float64 voltage5V\n\
float64 current5V\n\
bool enabled5V\n\
int32 faultCount5V\n\
float64 voltage6V\n\
float64 current6V\n\
bool enabled6V\n\
int32 faultCount6V\n\
RobotControllerCANData canData\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: frc_msgs/RobotControllerCANData\n\
float32 percentBusUtilization\n\
int32 busOffCount\n\
int32 txFullCount\n\
int32 receiveErrorCount\n\
int32 transmitErrorCount\n\
";
  }

  static const char* value(const ::frc_msgs::RobotControllerData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.fpgaVersion);
      stream.next(m.fpgaRevision);
      stream.next(m.fpgaTime);
      stream.next(m.userButton);
      stream.next(m.isSysActive);
      stream.next(m.isBrownedOut);
      stream.next(m.inputVoltage);
      stream.next(m.inputCurrent);
      stream.next(m.voltage3V3);
      stream.next(m.current3V3);
      stream.next(m.enabled3V3);
      stream.next(m.faultCount3V3);
      stream.next(m.voltage5V);
      stream.next(m.current5V);
      stream.next(m.enabled5V);
      stream.next(m.faultCount5V);
      stream.next(m.voltage6V);
      stream.next(m.current6V);
      stream.next(m.enabled6V);
      stream.next(m.faultCount6V);
      stream.next(m.canData);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RobotControllerData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::frc_msgs::RobotControllerData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::frc_msgs::RobotControllerData_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "fpgaVersion: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fpgaVersion);
    s << indent << "fpgaRevision: ";
    Printer<int64_t>::stream(s, indent + "  ", v.fpgaRevision);
    s << indent << "fpgaTime: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.fpgaTime);
    s << indent << "userButton: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userButton);
    s << indent << "isSysActive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isSysActive);
    s << indent << "isBrownedOut: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isBrownedOut);
    s << indent << "inputVoltage: ";
    Printer<double>::stream(s, indent + "  ", v.inputVoltage);
    s << indent << "inputCurrent: ";
    Printer<double>::stream(s, indent + "  ", v.inputCurrent);
    s << indent << "voltage3V3: ";
    Printer<double>::stream(s, indent + "  ", v.voltage3V3);
    s << indent << "current3V3: ";
    Printer<double>::stream(s, indent + "  ", v.current3V3);
    s << indent << "enabled3V3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enabled3V3);
    s << indent << "faultCount3V3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.faultCount3V3);
    s << indent << "voltage5V: ";
    Printer<double>::stream(s, indent + "  ", v.voltage5V);
    s << indent << "current5V: ";
    Printer<double>::stream(s, indent + "  ", v.current5V);
    s << indent << "enabled5V: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enabled5V);
    s << indent << "faultCount5V: ";
    Printer<int32_t>::stream(s, indent + "  ", v.faultCount5V);
    s << indent << "voltage6V: ";
    Printer<double>::stream(s, indent + "  ", v.voltage6V);
    s << indent << "current6V: ";
    Printer<double>::stream(s, indent + "  ", v.current6V);
    s << indent << "enabled6V: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enabled6V);
    s << indent << "faultCount6V: ";
    Printer<int32_t>::stream(s, indent + "  ", v.faultCount6V);
    s << indent << "canData: ";
    s << std::endl;
    Printer< ::frc_msgs::RobotControllerCANData_<ContainerAllocator> >::stream(s, indent + "  ", v.canData);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FRC_MSGS_MESSAGE_ROBOTCONTROLLERDATA_H
